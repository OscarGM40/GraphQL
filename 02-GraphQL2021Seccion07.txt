				INTRODUCCIÓN CON NODE-EXPRESS Y TYPESCRIPT A GRAPHQL
        CORRESPONDIENTE A LA SECCION 07 DEL CURSO UDEMY DE ANARTZ

		MIGRAR DE APOLLO SERVER EXPRESS 2 A LA VERSION 3

Fuente:https://www.youtube.com/watch?v=sQMFUDFgIEs&ab_channel=AnartzMugikaLedo-Desarrollo%26Formaci%C3%B3n

IMPORTANTE: si pongo el cursor en el package.json sobre la versión de una dependencia puedo ver su última versión:

Production-ready Node.js GraphQL server for Express
Latest version: 3.6.2
Dado que tengo esta("apollo-server-express": "2.25.3",) obviamente estoy desactualizado.

NOTA:para instalar una versión usaré @^number:
>npm install apollo-server-express@^3 <- instalame la más actual de la version 3
Siempre va a instalar la versíon más estable o actual de esa mayor release

PROBLEMAS A RESOLVER: 

UNO - makeExecutableSchema ya no vendrá de apollo-server-express sino de graphql-tools:
Cambiar 
import { makeExecutableSchema } from "apollo-server-express";
por
import { makeExecutableSchema } from 'graphql-tools';
Esto pedirá usar graphql-tools en v8+ ("graphql-tools": "8.2.0")
De la misma manera puedo usar npm i graphql-tools@^8

DOS: el playground ya viene activado en mode dev(y desactivado para prod,pero el como activarlo en prod Anartz lo dejó para otro momento)
 this.server = new ApolloServer({
      schema: this.schema,
      introspection: true, //necesario para producción
      playground: true //necesario para acceder al playground,activo desde la v3
    })
Simplemente lo quito:
    this.server = new ApolloServer({
      schema: this.schema,
      introspection: true, //necesario para producción
    })

NOTA:puedo borrar la carpeta node_modules y asegurarme que queda todo limpio con : npm cache clean --force. Despues hago el npm install de nuevo.
Esto lo puedo hacer cuando borre alguna dependencia desde el package.json,la borro alli,elimino la carpeta node-modules,limpio la cache y reinstalo todo.

ERROR TRES: debo usar await server.start() antes de llamar a server.applyMiddleware().Simplemente lo hago:

 await this.server.start(); <- me pide esto simplemente
 this.server.applyMiddleware({ app: this.app })

NOTA:puedo redireccionar de / a /graphql para ir al playground si quiero:
  this.app.get('/', (_, res) => {
      res.redirect('/graphql');
    });
Y recuerda que ya no usaré:
 this.app.use('/', expressPlayGround({
    endpoint: '/graphql'
  })); 

Con lo que no tengo que instalar esto:
import expressPlayGround from 'graphql-playground-middleware-express';

Usando apollo-server-core puedes volver al anterior playground, para mí sigue siendo mejor. Estoy tratando de usar subscripciones porque en esta versión no la soportan por defecto.

				CONFIGURAR TYPESCRIPT EN EL PROYECTO

Source: https://www.youtube.com/watch?v=NacgrA7l1ZA

Creo un proyecto Node y le instalo las siguiente dependencias:
npm install typescript.

Ahora creo el tsconfig con este módulo,dado que está en el proyecto únicamente,uso npx para ello:
npx tsc --init

Adecuo la configuración de typescript a lo que Anartz quiere,removiendo los Comments,permitiendo importar JSON y cambiando el rootDir y el outDir.Seguir video.
Fijate que en cuanto necesite importar archivos json tendré que activarlo,ya que viene desactivado por defecto en TS.
    "lib": ["DOM","ES2016"] <- librerías a usar.También queremos la DOM

						INSTALAR DEPENDENCIAS DEL PROYECTO

Voy a instalar express,graphql,ncp para copiar directorios,graphql-import-node para trabajar con archivos graphql ....

npm i -S express graphql ncp graphql-import-node compression cors graphql-tools graphql-playground-middleware-express apollo-server-express@^2

Y para desarrollo instalo las librerias para los definition types para:
npm i -D @types/compression @types/express @types/cors @types/node @types/graphql nodemon ts-node
Aparte de nodemon y ts-node para --save-dev.

				CONFIGURAR SCRIPTS EN EL PACKAGE.JSON

Vamos a definir tres scripts.Para hacer el build necesitaremos de la libreria ncp que copia directorios,tal como hemos acordado:
 "build": "npx tsc -p . && ncp src/schema build/schema",

Para dev vamos a usar nodemon y ts-node en conjunción,aunque también podría haber usado ts-node-dev,esto no es importante mientras tenga reload:

"dev":"nodemon src/app.ts --exec ts-node src/app.ts -e ts,graphql,json",
Fijate que con -e le paso las extensiones.Interesante

Por último start será el comando que levante la app una vez buildeada:
"start": "node build/app.js" 
Genial.Todo sencillo hasta ahora.

				    	CONFIGURAR SERVIDOR EXPRESS

Fijate que él crea el servidor con createServer del modulo core http y que declara una ruta GET con app.use.Investigar sobre el módulo compression:

import express from 'express';
import cors from 'cors';
import compression from 'compression';
import { createServer } from 'http';

const app = express();

/* Middlewares */
app.use(cors());
app.use(express.json());
// Comprimo el proyecto con compression
app.use(compression());

app.use('/', (_, res) => {
  res.send('Bienvenidos/as al curso de GraphQL');
});

const httpServer = createServer(app);

httpServer.listen({
  port: process.env.PORT || 3003,
}, () => {
  console.clear();
  console.log('Servidor corriendo en el puerto 3003');
});

NOTA: el modulo compression comprime las responses que envia el server a gzip.En principio es sólo usarlo como middleware pero puede configurarse.Investigar más.Parece bueno.	

				SERVIDOR API GRAPHQL - PRIMERAS CONFIGURACIONES

IMPORTANTE:en un resolver siempre hay cuatro argumentos,el primero es un objeto indefinido,el segundo son los args y el tercero es el contexto.El contexto es la información para compartir con por ejemplo la base de datos,el token,la Subscription,etc... 
El cuarto es la info,que me da información sobre esa query o mutation.Lógicamente si quiero llegar hasta la info tengo que definir los cuatro,pero son opcionales:
 const resolverDefinitions = {
  Query:{
    helloWithName(root:object, args:{name: string}, context:object,info:object){}

Fijate que todos los argumentos son de tipo objeto.

Bien,en cuanto a los pasos a seguir,primero hay que crear los typeDefinitions,despues los resolvers:

/* Definir  los typeDefinitions*/
const typeDefinitions = `
  type Query {
    hello: String!
    helloWithName(name: String!): String!
    peopleNumber: Int!

  }
`;

/* DOS Dar solución a las definiciones anteriores */
const resolverDefinitions = {
  Query: {
    hello: (): string => 'Hello World!',
    helloWithName: (
      _: object,
      args: { name: string },
      __: object,
      info: object): string => {
        console.log(info);
        return `Hello ${args.name}`
    },
    peopleNumber: () => 1
  }
};

/* TRES Construir el schema */
const schema: GraphQLSchema = makeExecutableSchema({
  typeDefs: typeDefinitions,
  resolvers: resolverDefinitions
});

Es en este paso tres donde entra apollo-server-express ya que hay que importar el método makeExecutableSchema de él.Para crear el schema si que se usa el módulo core:
import { GraphQLSchema } from 'graphql';
import { makeExecutableSchema } from 'apollo-server-express';

Los pasos 4 y 5 crean el servidor apollo y le aplican el servidor express como middleware:

/* CUATRO CONFIGURAR EL SERVIDOR APOLLO SERVER */
const server = new ApolloServer({
  schema,
  introspection: true, //necesario para producción
  playground: true //necesario para acceder al playground
});

/* QUINTO aplicar el middleware a este nuevo servidor*/
server.applyMiddleware({ app });

Para poder usar una interfaz web con apollo-server hay que usar su playground:

app.use('/', expressPlayGround({
  endpoint: '/graphql'
}));
Creo que esto es opcional.Investigar

Ahora ya puedo ir a /graphql y ver la interfaz web.Fijate que normalmente los types y los resolvers van a venir de varios lados

					REFACTORIZAR PASOS ANTERIORES.

Una forma de refactorizar el código anterior es usando una clase:

class Server {
  constructor(){
    this.initialize();
  }
  /* inicializar todas las configuraciones */
  private initialize(): void {
  }

  private configExpress(){}
  private configApolloServer(){}
  private configRoutes(){}
  private createServer(){}

  listen(){

  }
  
}

export default Server;

Al final la clase quedará asi(fijate que no llamo al listen en el initialize pero incluso podría llamarlo:
import express from 'express';
import cors from 'cors';
import compression from 'compression';
import { GraphQLSchema } from 'graphql';
import {
  ApolloServer,
  makeExecutableSchema
} from 'apollo-server-express';
import expressPlayGround from 'graphql-playground-middleware-express';
import { createServer, Server as HTTPServer } from 'http';


class Server {
  private app!: express.Application;
  private schema!: GraphQLSchema;
  private server!: ApolloServer;
  private httpServer!: HTTPServer;
  private readonly DEFAULT_PORT_SERVER: number= +process.env.PORT! || 3003;

  constructor() {
    this.initialize();
  }

  /* inicializar todas las configuraciones */
  private initialize(): void {
    this.configExpress();
    this.configApolloServer();
    this.configRoutes();
    this.createServer();
  }

  private configExpress() {
    this.app = express();
    this.app.use(cors())
    this.app.use(compression())

  }

  private configApolloServer() {
    /* UNO Definir  los typeDefinitions*/
    const typeDefinitions = `
      type Query {
        hello: String!
        helloWithName(name: String!): String!
        peopleNumber: Int!
      }
    `;
    /* DOS Dar solución a las definiciones anteriores */
    const resolverDefinitions = {
      Query: {
        hello: (): string => 'Hello World!',
        helloWithName: (
          _: object,
          args: { name: string },
          __: object,
          info: object): string => {
          return `Hello ${args.name}`
        },
        peopleNumber: () => 1
      }
    };
    /* TRES Construir el schema */
    this.schema = makeExecutableSchema({
      typeDefs: typeDefinitions,
      resolvers: resolverDefinitions
    });
    /* CUATRO CONFIGURAR EL SERVIDOR APOLLO SERVER */
    this.server = new ApolloServer({
      schema: this.schema,
      introspection: true, //necesario para producción
      playground: true //necesario para acceder al playground
    })
    /* QUINTO aplicar el middleware a este nuevo servidor*/
    this.server.applyMiddleware({ app: this.app })
  }

  private configRoutes() {
    this.app.use('/hello', (_, res) => {
      res.send('Bienvenidos/as al curso de GraphQL by Anartz por la tarde');
    });

    this.app.use('/', expressPlayGround({
      endpoint: '/graphql'
    }));
  }

  private createServer() {
    this.httpServer = createServer(this.app);
  }

  listen(): void {
    this.httpServer.listen(this.DEFAULT_PORT_SERVER, () => {
      console.clear();
      console.log('Apollo Server on http://localhost:3003/graphql')
    })
  }

}

export default Server;

En el app.ts simplemente llamo al servidor:

import Server from "./server";

const server = new Server();
server.listen();

Fijate que es muy interesante esta forma con clases y no es dificil,además de ser muy formativa.Bien,pero si me fijo atentamente veo que los resolvers y los typeDefinitions deberían venir desde otro archivo también.

NOTA:los tipos de definición y los resolvers siempre deberían de venir desde otro archivo.Asi pues creo dos directorios, resolvers y schema(fijate que en schema van a ir archivos con extensión .graphql):

IMPORTANTE:es en este directorio schema donde van a ir los typeDefinitions,aparte de la fusión con los resolvers y la creación del schema:

En el .graphql:
type Query {
  hello: String!
  helloWithName(name: String!): String!
  peopleNumber: Int!
}

Fijate que es lo que habia entre las comillas invertidas anteriormente.Bien,ahora falta crear el schema.

IMPORTANTE: Para poder importar un archivo con extensión .graphql vamos a necesitar la librería 'graphql-import-node',la cual ya hemos instalado.De lo contrario no podremos importar nada desde un graphql.Además,es obligatorio que sea el primer import(o al menos que esté por encima del que se trae el archivo):
 
import "graphql-import-node" <- siempre arriba
import typeDefinitions from "./schema.graphql" <- es una import default,puedo darle cualquier nombre.

Realmente es muy sencillo,si tengo dudas puedo volver a consultar el video o el proyecto,pero se trata de crear dos directorios y refactorizar todo bien:

import typeDefinitions from "./schema.graphql";
import 'graphql-import-node';
import { resolvers } from "../resolvers";

export const schema: GraphQLSchema = makeExecutableSchema({
  typeDefs: [typeDefinitions],
  resolvers: resolvers,
});

Ahora vamos a hacer una cosa interesante y es pedir el schema de GraphQLSchema en el constructor del server.Si no se proporciona uno lanzaremos un error:

  private schema!: GraphQLSchema;
  private readonly DEFAULT_PORT_SERVER: number= +process.env.PORT! || 3003;

  constructor(schema: GraphQLSchema) {
    if(schema === undefined) {
      throw new Error('El schema no puede ser undefined');
    }
    this.schema = schema;
    this.initialize();
  }

Lógicamente esto implica proporcionar un schema al realizar el new Server():
const server = new Server(schema);

IMPORTANTE: fijate que no puede resolver el .graphql por el orden de los imports:
type Query {
     ^^^^^
SyntaxError: Unexpected identifier
Lo habiamos dejado mal a propósito,pero los imports son secuenciales asi que su orden importa:

import 'graphql-import-node'; <- SIEMPRE EL PRIMERO
import { makeExecutableSchema } from "apollo-server-express";
import { GraphQLSchema } from "graphql";

import typeDefinitions from "./schema.graphql";
import { resolvers } from "../resolvers";

				TRABAJANDO CON LA FAKE DATA EN LOS JSON

Ya habiamos acordado que vamos a trabajar con fake data en archivos JSON.Usarmos dos archivos,uno de cursos y otro de alumnos.Un curso luce asi:
    {
      "id": "1",
      "title": "Compodoc: Crea documentación en proyectos Angular/Ionic/TS",
      "description": "Crear documentación de calidad y MUY fácil de mantener con Compodoc para proyectos de Angular 2+ / Ionic 2+ / Typescript",
      "clases": 73,
      "time": 3.5,
      "level": "MEDIUM",
      "logo": "https://i.udemycdn.com/course/240x135/1777518_b681_6.jpg",
      "path": "/compodoc-crea-documentacion-en-angular-ionic",
      "teacher": "Anartz Mugika Ledo",
      "price": 0,
      "reviews": [
        {
          "id": "1",
          "name": "Juan Gómez Navarro",
          "points": 4.5,
          "comment": "Muy buen curso, justo lo que necesitaba!"
        }
      ]
    },
Como puedo ver tiene bastantes propiedades y de vatios tipos.Un estudiante luce algo más sencillo:
 {
        "id": "1",
        "name": "Leanne Graham",
        "email": "Sincere@april.biz",
        "website": "hildegard.org",
        "courses": [
           "1", "2"
        ]
  },

IMPORTANTE: el array courses tiene los IDS de los cursos,es decir que apunta a una PK

				QUERY LISTA DE ESTUDIANTES

Simplemente creo la type definition:

type Query {
  hello: String!
  helloWithName(name: String!): String!
  peopleNumber: Int!
  " custom scalar "
  students: [Student!]!
}
""" custom object """
type Student {
  id: ID!
  name: String!
  email: String!
  website: String!
  courses: [String!]!
}
Fijate que para comentar son triples comillas y que tengo que crear ya un custom tipe.En el resolver habrá que dar solución(o resolver) esta definición.

Diria que un scalar es un tipo en GraphQL.Cada vez que cree un custom scalar como en este caso es Student si estoy en TS tengo que crear su interface:
export interface IStudent {
  id: string | number;
  name: string;
  email: string;
  website: string;
  courses: Array<string>;
}
Fijate que el id realmente puede ser un number y que courses es un array de strings(string[]).Aunque también puedo usar Array<string>(investigar diferencias).
Parece que es simplemente otra forma de definir arreglos.

Creo la solución del resolver
  students(_:object,{},{},info:object): IStudent[] {
      return data.students;
    },

					QUERY BUSCAR ESTUDIANTE POR ID

IMPORTANTE:fijate que buscar por ID puede no devolver un valor(es decir que puede ser nulo).Asi que no puedo asegurar que devuelva un Student asi(Student!):

"listar un estudiante por id"
 studentById(id:ID!): Student

Si pusiera que siempre tiene que devolver un Student con Student! cuando pida un estudiante con un id que no existe me dará el siguiente error:
Cannot return null for non-nullable field Query.studentById <- ya puedo ver que me dice que está retornando null y que he definido el campo como no nulo.

NOTA: cuando esté trabajando con los rootTypes Query,Mutation o Subscription el primer argumento del resolver siempre va a ser indefinido(será definido cuando trabaje con parent,con el padre):
 
  studentById(_:object,args:{id:string}): IStudent | undefined
  {
    return database.students.find(student => student.id === args.id);
  }
Recuerda que cuando busco uno find es más eficiente que filter.

La query en el playground quedaría asi:
query buscar($ID:ID!) {
  studentById(id:$ID){
    id
    name
    email
    website
  }
}
Pero fijate que si pongo ese $ID con un valor que no devuelva un Student la respuesta será esta:
{
  "data": {
    "studentById": null
  }
}
Esto no es bueno,debería dar más feedback como un statusCode y un mensaje más descriptivo

			MEJORANDO FEEDBACK EN LAS RESPUESTAS DE GRAPHQL

Siempre hay que tratar la respuesta.Para ello podemos crear otro custom scalar:

type Result {
  status:Boolean!
  message:String!
  list:[Student!]
  item:Student
}
Fijate que la lista de Student o el Student no pueden ser obligatorios,pues pueden ser null(sin embargo ahora si que va a ser obligatorio que se devuelva un Result!):
type Query {
  "listar estudiantes"
  students: Result!
  "listar un estudiante por id"
  studentById(id:ID!): Result!
}
Lógicamente ahora hay que ir a las soluciones de las queries y en los resolvers devolver una respuesta acorde a este objeto que la tipa.

  Query: {
    students(_:object,{},__:{},___:object): {
      status:boolean;
      message:string;
      list:IStudent[]
    } 
    {
      return {
        status:true,
        message:"Lista correctamente cargada",
        list:database.students
      };
    },

Lo mismo para el estudiante:
 studentById(_:object, args: {id:string} ): {
      status:boolean;
      message:string;
      item: IStudent | null;
    }
    {
      const student = database.students.find(
        (student:IStudent) => student.id === args.id);

      return { 
        status:student === undefined ? false : true,
        message:student 
          ? "Estudiante correctamente cargado"
          : "Estudiante no encontrado con el id "+args.id,
        item: student ? student: null
      }
    },
Ahora si pido uno que no exista veré un feedback mucho mejor:
{
  "data": {
    "studentById": {
      "status": false,
      "message": "Estudiante no encontrado con el id 11",
      "item": null
    }
  }
}
Lo importante es entender que puedo programar lo que quiera

				QUERY LISTAR CURSOS Y LISTAR UN CURSO

Creo otra interfaz y su schema:

export interface ICourse {
  id: string | number;
  title: string;
  description: string;
  clases:number;
  time: number;
  level: string;
  logo: string;
  teacher: string;
  path: string;
  price: number;
}

IMPORTANTE: fijate que cuando tenga varios archivos en una carpeta es mucho mejor ser organizado y exportar importar en bloque.Asi,dentro del folder interfaces creo un index.ts y exporto todo desde él:

En el folder/index.ts
export * from './course.interface';
export * from "./student.interface";
export * from ...
Y ahora ya no usaré tantos imports:
import { ICourse, IStudent } from "../interfaces"; <- en otro archivo
Perfecto.Gran consejo.

		RELACIONES N-M ENTRE CURSO - ESTUDIANTE(PARENT)- MODIFICAR UNA PROPIEDAD

Fijate en el campo courses:
type Student {
  "id del estudiante"
  id: ID!
  name: String!
  email: String!
  website: String!
  courses: [Course!]!
}

Llegados a este punto hay que entender que son los typeResolvers.Yo puedo tomar un scalar ya definido,como es el caso de Student y modificarlo en otro archivo:

const typesResolver = {
  Student: { 
    website:(root:{website:string}) => {
      return "Web:".concat(root.website.replace("http://","https://")).concat(;
    },
  }
}

export default typesResolver;

Puedo hacer algo tan sencillo como reemplazar una letra.Obviamente tengo que fusionar este resolver con los demás para devolver uno solo:

export const resolvers = {
  ...queryResolvers,
  ...typesResolver
}
Si ahora pido un Student va a modificar ese campo.
  "website": "Web:hildegard.org"

Bien,ahora que ya sé como modificar una propiedad,lo que vamos a hacer es pedir los cursos en un array de strings(["1","2]) y transformar la salida con esta técnica:

const typesResolver = {
  Student: { 
    courses:(root: {courses:string[]} ) => {
      return data.courses.filter(
        course => root.courses.includes(course.id))
    }
También valdría con root.courses.indexOf(course.id) > -1 .Si es mayor de -1 es que lo ha encontrado
LLegados a este punto hay que hacer lo mismo pero poblando los estudiantes que se han apuntado al curso.
IMPORTANTE:en el primer argumento del resolver tengo toda la data.Sabiendo esto,puedo por ejemplo hacer la query de un curso y con ese arg.id ver todos los students que en su propiedad cursos están apuntados a ese curso:

type Course {
  id: ID!
  title: String!
  description: String!
  clases: Int!
  time: Float!
  level:Level!
  logo:String!
  path: String!
  teacher: String!
  price: Float!
  students:[Student!]! <- no necesito el id,ya me lo da el primer arg:

const typesResolver = {
  Student: { 
    website:(root: {website:string} ) => {
      return "Web:".concat(root.website.replace("http://","https://"));
    },
    courses:(root: {courses:string[]} ) => {
      return data.courses.filter(
        course => root.courses.includes(course.id))
    }

  },
  Course: {
  students: (root:{id:string} ) <- puedo acceder a lo que quiera => {
  return data.students.map( student => student.courses.includes(root.id) <-Genial

En la propiedad course.path vamos también a modificar ese path anteponiendole un substring.Recuerda que esto va en el resolver de tipos
   path: (root: { path:string } ) => {
      return "https://udemy.com/course".concat(root.path);
    },
Obviamente puedo usar template strings y hacer todo en una linea,por ejemplo:
path: (root: {path:string}) => `https://udemy.com/course${root.path}`;

							UNION - DATA 

Si nos fijamos en estos dos types veré que son practicamente iguales:
type ResultStudent {
  status:Boolean!
  message:String!
  list:[Student!]
  item: Student
}

type ResultCourse {
  status:Boolean!
  message:String!
  list:[Course!]
  item: Course
}
Puedo hacer uso de Union y unir las respuestas en una sola y no devolver directamente Student o Course sino simplemente Data que segun la respuesta será Student o Course.
Las unions e interfaces son tipos de schema abstractos GraphQL que permiten a un campo del schema devolver uno o multiples tipos:
union Media = Book | Movie

En nuestro caso vamos a usar esta unión.Simplemente la declaro en el schema.graphql:
union Data = Student | Course

Una vez declarada hay que ir al resolver de types y darle solución.Debo buscar un par de propiedades que sean distintas en cada Modelo.En este caso Student tiene un name y Course tiene un title:

  Data: {
    __resolveType(obj: { name: string, title: string }) {
      if (obj.name) {
        return "Student";
      } else if (obj.title) {
        return "Course";
      } else {
        return null;
      }
    }
  }

Y por último al hacer la query tengo que usar ...on <Type> y decirle que quiero según sea un Student o un Course:

query Students {
  students {
    status
    message
    list{
      ...on Student{
        ...StudentFrag
      }
    }
  }
}
fragment StudentFrag on Student {
  id
  name
  website
  email
 }
Recuerda que puedo crear un fragment temporal con la sintaxis 'fragment <name> on <ModelName>.Ejemplo: fragment StudentFrag on Student {}.
Y para usarse es con ...fragmentName,ojo.

Fijate que ahora todos devuelven un Result y segun tenga una propiedad u otra filtraremos el custom scalar a devolver:

union Data = Student | Course

type Result {
  status:Boolean!
  message:String!
  list:[Data!]
  item: Data
}

type Query {
  "listar estudiantes"
  students: Result!
  "listar un estudiante por id"
  studentById(id:ID!): Result!
  "listar todos los cursos"
  courses: Result!
  "listar un curso filtrando por ID"
  courseById(id:ID!): Result!
}

Genial.Recuerda que cuando haya una union tengo que usar ...on Type en el playground de Apollo.
IMPORTANTE: puedo crear y embeber tantos fragments como quiera:

query CourseById($courseByIdId: ID!) {
  courseById(id: $courseByIdId) {
    status
    message
    item {
      ... on Course {
        ...CourseObject
      }
    }
  }
}

fragment CourseObject on Course {
  id
  description
  clases
  level
  logo
  price
  students {
    ...StudentFrag
      }
}

fragment StudentFrag on Student {
  id
  name
  website
}

					MUTATIONS- PRIMEROS PASOS Y PREPARATIVOS

En el schema.graphql,justo debajo de type Query creo otra sección para las mutaciones.De momento hacemos algo muy básico,ya que realmente recibiré muchos argumentos y no devolveré un Boolean:

type Mutation {
  "añadir un curso"
  addCourse(id:ID!):Boolean
  "editar un curso"
  updateCourse(id:ID!):Boolean
  "eliminar un curso"
  deleteCourse(id:ID!):Boolean
}

En los resolvers me creo el fichero mutation.ts(fijate que tenia query.ts,types.ts y el index para mergear la salida).Si usará subscripciones obviamente me quedaría ese file por crear.

Recuerda mergear los resolvers en ese file:

export const resolvers = {
  ...queryResolvers,
  ...mutationResolvers,
  ...typesResolver,
}

						INPUT TYPE FOR MUTATIONS

REalmente podría introducir los valores individualmente,pero es mucho mejor usar un único argumento que debe declarse con 'input <Name>.
IMPORTANTE: este nuevo type 'input'  me lo proporciona GraphQL y debo usarlo para especificar entrada de datos por argumento:

* Por convención suele llamarse xxxInput

input CourseInput {
  title: String!
  description: String!
  clases: Int!
  time: Float!
  level:Level=ALL <- asignación por defecto
  logo:String!
  path: String!
  teacher: String!
  price: Float!
}

Fijate que queda bien claro que es un valor de entrada.En cuanto al Level puedo asignar un valor de entrada a cualquier propiedad con =.Ejemplo clases: Int=0.
Obviamente ya no será Int! pues no va a ser undefined más.

La mutation ya no usará el ID(olvidate de eso ya):
type Mutation {
  "añadir un curso"
  addCourse(course:CourseInput!):Boolean

Ya sólo queda darle solución en el resolver.Fijate que no voy a necesitar los argumentos 1,3 y 4,y que el segundo argumento es de tipo ICourse,claro:
   
addCourse: (root: object, course: ICourse) => {
   console.log(course);
   return true;
}

De momento queremos ver sólo lo que introduzcamos por consola.Usaré una query Variable en el playground:

mutation AddCourse($course:CourseInput!) {
  addCourse(course: $course)
}
** Query Variable **
{
  "course": {
    "title": "El curso del moko",
    "description": "Moko vuelve a la ciudad",
    "clases": 1,
    "time": 5.5,
    "logo": "logo muy feo",
    "path": "path hacia alli",
    "teacher": "Anastasio",
    "price": 100      
  }
}

Debería ver todo por consola y ver el true según tenemos la lógica.Y así sucede:

Apollo Server on http://localhost:3003/graphql
{
  course: {
    title: 'El curso del moko',
    description: 'Moko vuelve a la ciudad',
    clases: 1,
    time: 5.5,
    level: 'ALL',
    logo: 'logo muy feo',
    path: 'path hacia alli',
    teacher: 'Anastasio',
    price: 100
  }
}
Haz todos los ejercicios bien y tranquilo
3h10m
